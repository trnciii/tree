# BVHは直線上につくろう

[芸工生 Advent Calendar 2020](https://adventar.org/calendars/5827) の12/12 に参加しています。

BVHという階層状のデータ構造について、得られた階層の接続関係を扱いやすい形で格納する方法について書きます。
階層そのものの構築方法については詳しく書きません。

## 背景
[BVH](https://en.wikipedia.org/wiki/Bounding_volume_hierarchy)はたくさんのオブジェクトに対して近傍探索や交差判定を効率的に行うためのデータ構造です。
以下のような、位置の近いオブジェクトが階層的に包括される木構造になっています。
またオブジェクトを包んでいるそれぞれの箱N1, N2,... をノードといいます。

![](http://www.bwfischer.com/418/bvhNvidia.png)<br>
image: [http://www.bwfischer.com/oculusRayTracer.html](http://www.bwfischer.com/oculusRayTracer.html)

近傍探索をおこなうとき、親ノードのほうから距離を調べます。
ノードが判定に引っかかったら、下の階層での判定にすすみます。
親ノードが判定に引っかからなかったら、それより下あるオブジェクトとの判定をまとめてスキップすることができ、処理を減らすことができます。

## 問題
この構造における親子関係を表現するのに最も簡単な実装のひとつは、ポインタを使って子供のノードやオブジェクトを指すことです。
しかし、この方法では親子関係をたどるたびにポインタを参照する必要があります。
また、データの複製や受け渡しを行うたびにポインタを更新する必要があるのが大変です。
(特に異なるメモリ空間での受け渡しは面倒)

そこでノードをひとつの配列に格納し、相対的な位置で親子関係を表現することでこれを解決します。

## 考え方
すべてのノードとオブジェクトは、判定をおこなう順で一直線に並べることができます。
ノードの左の子から先に判定をおこなうと決めると、上の図にあるノードは次のように並びます。

ノード: { N1, N2, N4, N5, N3, N6, N7 }<br>

基本的にこの配列を前から見ていって判定をおこなえばよいです。
これは以下のような処理の流れを表しています。
再帰的にすべてのノードの探索をおこなう順番になっていることがわかるでしょうか。

* N1はまず左の子であるN2の判定に進む
* N2の判定では左からN4, N5の順で判定をおこなう
* ここでN2の判定が終了し、N3に進む
* 以下同様...

自ノードが判定に引っかからず、子供の探索をスキップする場合はどうすればよいでしょうか。
いま処理の順でノードが並んでいるので、何個のノードをスキップするかがわかっていれば添字(array[i]のi)を進めることで実現できます。

具体的に、N2より下をスキップしN3に進むには配列を3個分進めればよいです。
N4の子をスキップするにはノードの配列を1個進めます。

この"スキップする個数"は自分以下にあるノードの総数です(自分を含む)。
N1, N3, N7は実際にはスキップ先が存在しませんが、プログラミング的な問題としては同様の操作でスキップした先が配列の長さを超えるので、繰り返しの終了判定になります。

(ノード, スキップする個数): { (N1, 7), (N2, 3), (N4, 1), (N5, 1), (N3, 3), (N6, 1), (N7, 1) }


## 実装
ノードの構造, BVH構築, 近傍探索の一例を疑似コードで示します。
BVH構築は、親のほうからオブジェクトの配列を子ノードに分割していくトップダウン方式でおこないました。

**ノード**

```cpp
struct Node{
	// オブジェクトを包む直方体
	vec3 min;
	vec3 max;

	// ノードが含むオブジェクトの配列とその個数
	iterator begin;
	int size;

	// スキップする個数
	int next;

	// オブジェクトの配列を受け取ってnext 以外を初期化
	Node(iterator begin, iterator end);

	// 位置pと半径rに交差するかの判定
	bool intersect(vec3 p, float r);
};
```

**BVH構築**

与えられたオブジェクトの配列を２分割し、新たなノードを追加していきます。
追加前後でノードの配列サイズを見て下にあるノードの数を求めます。

```cpp
vector<Node> nodes;　// ノードの配列

// オブジェクトの配列を受け取り、nodesに要素を追加する関数
split(iterator object_begin, iterator object_end){

	// object_mid で配列を適当に2分割する
	iterator object_mid = ~~~;


	int p0 = nodes.size();
	
	nodes.push_back(Node(object_begin, verts_mid)); // 左のノードを追加
	// 再帰でsplit を呼んで子以下のノードも追加
	if(splittable) split(object_begin, verts_mid);
	
	int p1 = nodes.size();

	nodes.push_back(Node(verts_mid, object_end)); // 右のノードを追加
	if(splittable) split(verts_mid, object_end); // 子以下のノードを追加

	int p2 = nodes.size();

	nodes[p0].next = p1 - p0; // 左のノード以下のノード数
	nodes[p1].next = p2 - p1; // 右のノード以下のノード数
}
```

**近傍探索**

入力された位置と半径に交差する物体すべてを配列として返します。
ノードの配列を前から見ていきますが、現在のノードと交差しないときは子供をスキップします。

```cpp
vector<Node> nodes; // ノードの配列

// 位置pと半径rに交差する物体すべての配列を返す
vector<Object> search(vec3 p, float r){

	vector<Result> result;
	iterator node = nodes.begin();

	while(node < nodes.end()){ // 配列の終端までの繰り返し
		if(node->intersect(p, r)){ // ノードの交差判定

			if(ノードが末端?)
				オブジェクトの交差判定とresult への追加;

			node++; // スキップせず次のノードに動く
		}
		else node += node->next; // ノードと交差しないときスキップする
	}

	return result;
}
```




各ファイルに以下の実装が書かれています。コメント等なくてすみません。

|ファイル|内容|
|:-:|:-:|
|Random.h|乱数(テストコードで利用)|
|kdtree.h|BVH本体のクラス|
|main.cpp|テスト|
|print.h|デバグ用出力|


## まとめ
### 嬉しかったこと

* ノードごとにポインタを確保/開放しなくてよい
* iterator を使って探索できる
* 木構造の受け渡しが簡単になった

### todo

* ポインタを使う実装との速度比較
